clear
clc
addpath('../discretization');
addpath('../motion-model');
addpath('../post-processing');
addpath('../standard-problem');
addpath('../test-functions');
%% defining problem parameters
Mbig = 1;
Msmall = 0.1;
m_tot = Mbig + Msmall;
R = 0.2;
l = 0.1;
J = getMoments(Mbig, Msmall, R, l);
k_tau = 1;
g = 9.81;
tol = 1e-4;
info = struct('m',m_tot,'g',g,'J',J,'l',l,'k_tau',k_tau,'tol',tol);
n = 12; %Number of states
m = 4; %Number of inputs
info.dimM = m;
info.Nstates = n;
info.nMPC = 40;
info.Nsteps = 20;
info.substeps = 5; %steps to be used with integrator
info.rho = .1; %multiplier to control inputs in cost function
nMPC = info.nMPC; %N steps ahead in MPC
Ts = 0.05;
info.Ts1 = Ts; %time step to be used in integrator
info.post_processing = false;
% Q0 = [diag([49 49 0]) zeros(3) zeros(3) zeros(3); zeros(9,3) zeros(9)];
% Q = getQbar(Q0,n,nMPC);
info.R = eye(info.dimM*info.Nsteps);
%% SUMT Initialization

info.x0 = zeros(12,1);
info.xf = [10,6.5,5];
info.motorlimit = 3*2.6978; %approx 3:1 power to weight


U0 = ones(m*info.Nsteps,1) * 2.6978;     %create initial input for minimization
%U0 = [U0; info.Ts1];            %add Ts to input vector
Nsteps = info.Nsteps;
info.post_processing = true;
info.two_sample_times = false;

iter = 1;
info.rp = 1;

h = equalCon(U0, info);
g = inequalCon(U0, info);

info.lamg = zeros(size(g));
info.lamh = [-1; -1; 1]; %%% NEED TO CHANGE
gam = 5;

fnew = costFun(U0, info);
fold = 2 * fnew;

options = optimoptions(@fminunc,'Algorithm', 'quasi-newton', ...
    'Display', 'iter','SpecifyObjectiveGradient', false);

maxiter = 100;

tic
while abs(fnew-fold) >= 1e-9 && iter<maxiter
    lambda_g = info.lamg;
    lambda_h = info.lamh;
    rp = info.rp;
    
    fold = fnew;  % store last objective function value
    % call fminunc - use "ALM" pseudo-objective function, note that r_p and
    % lambda are passed as parameters, no semi-colon to display results
    [Ustar,phistar,exitflag] = fminunc(@(U)psuedoFun(U, info),U0,options);
    % compute objective and constraints at current xstar
    f = costFun(Ustar, info);
    fnew = f;
    g = inequalCon(Ustar, info);
    h = equalCon(Ustar, info);
    
    
    % update lagrange multipliers
    for i = 1:Nsteps%+2
        lambda_g(i) = lambda_g(i) + 2 * rp * max( g(i), -lambda_g(i)/(2*rp));
    end
    
    
    for j = 1:3
        lambda_h(j) = lambda_h(j) + 2*rp*h(j);
    end
    iter = iter + 1;     % increment minimization counter
    info.rp = rp * gam; % increase penalty multiplier (gamma = 5, here)
    U0 = Ustar;    % use current xstar as next x0
    
end
toc

x0 = info.x0;
 xref = predictStates(x0,Ustar,info);
 [xi, yi, zi] = extractPos(xref, info.Nsteps+1);
 figure(1)
 plot3(xi,yi,-zi)

























